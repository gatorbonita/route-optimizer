<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Route Optimizer - Save Time Visiting Multiple Places</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            height: 100vh;
            overflow: hidden;
            margin: 0;
            padding: 0;
        }
        .container {
            height: 100vh;
            display: flex;
            flex-direction: column;
            max-width: 1400px;
            margin: 0 auto;
            padding: 0 20px;
        }
        header {
            text-align: center;
            padding: 20px 0 15px;
            flex-shrink: 0;
        }
        header h1 {
            color: white;
            font-size: 2rem;
            margin-bottom: 5px;
            font-weight: 700;
            text-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        header p {
            color: rgba(255, 255, 255, 0.9);
            font-size: 0.95rem;
        }

        /* Sidebar collapse button for desktop */
        .sidebar-toggle {
            position: absolute;
            top: 50%;
            right: -15px;
            transform: translateY(-50%);
            width: 30px;
            height: 60px;
            background: white;
            border: none;
            border-radius: 0 10px 10px 0;
            box-shadow: 2px 0 8px rgba(0,0,0,0.1);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.2rem;
            color: #667eea;
            transition: all 0.3s;
            z-index: 10;
        }
        .sidebar-toggle:hover {
            background: #f8f9fa;
        }
        .sidebar.collapsed {
            width: 0;
            min-width: 0;
            padding: 0;
            overflow: hidden;
        }
        .sidebar.collapsed .sidebar-toggle {
            right: -30px;
        }

        /* Mobile tabs */
        .mobile-tabs {
            display: none;
            background: white;
            border-radius: 12px;
            padding: 8px;
            margin-bottom: 12px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
        }
        .mobile-tabs-container {
            display: flex;
            gap: 8px;
        }
        .mobile-tab {
            flex: 1;
            padding: 12px 8px;
            background: transparent;
            border: none;
            border-radius: 8px;
            font-size: 0.85rem;
            font-weight: 600;
            color: #7f8c8d;
            cursor: pointer;
            transition: all 0.3s;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 4px;
        }
        .mobile-tab-icon {
            font-size: 1.3rem;
        }
        .mobile-tab.active {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            box-shadow: 0 2px 8px rgba(102, 126, 234, 0.3);
        }

        /* Mobile bottom sheet for results */
        .results-bottom-sheet {
            display: none;
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            background: white;
            border-radius: 20px 20px 0 0;
            box-shadow: 0 -4px 20px rgba(0,0,0,0.15);
            max-height: 50vh;
            transform: translateY(100%);
            transition: transform 0.3s ease;
            z-index: 1000;
        }
        .results-bottom-sheet.show {
            transform: translateY(0);
        }
        .bottom-sheet-handle {
            width: 40px;
            height: 4px;
            background: #ddd;
            border-radius: 2px;
            margin: 12px auto 8px;
        }
        .bottom-sheet-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 20px 12px;
            border-bottom: 1px solid #e8e8e8;
        }
        .bottom-sheet-close {
            background: none;
            border: none;
            font-size: 1.5rem;
            color: #7f8c8d;
            cursor: pointer;
            padding: 4px 8px;
            line-height: 1;
        }
        .bottom-sheet-content {
            overflow-y: auto;
            max-height: calc(50vh - 80px);
            padding: 15px 20px;
        }
        .main-content {
            display: grid;
            grid-template-columns: 340px 1fr;
            gap: 20px;
            flex: 1;
            min-height: 0;
            padding-bottom: 20px;
        }
        .main-content.with-results {
            grid-template-columns: 340px 1fr 380px;
        }
        .sidebar {
            background: white;
            border-radius: 16px;
            padding: 20px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.12);
            display: flex;
            flex-direction: column;
            overflow: hidden;
            height: 100%;
            position: relative;
            transition: all 0.3s ease;
        }
        .sidebar-content {
            flex: 1;
            overflow-y: auto;
            padding-right: 8px;
        }
        .sidebar-content::-webkit-scrollbar {
            width: 6px;
        }
        .sidebar-content::-webkit-scrollbar-track {
            background: #f1f1f1;
            border-radius: 10px;
        }
        .sidebar-content::-webkit-scrollbar-thumb {
            background: #c1c1c1;
            border-radius: 10px;
        }
        .sidebar-content::-webkit-scrollbar-thumb:hover {
            background: #a8a8a8;
        }
        .section-title {
            font-size: 1rem;
            color: #2c3e50;
            margin-bottom: 15px;
            font-weight: 700;
            letter-spacing: -0.5px;
        }
        .input-group {
            margin-bottom: 12px;
        }
        .input-group label {
            display: block;
            font-size: 0.8rem;
            color: #7f8c8d;
            margin-bottom: 4px;
        }
        .input-group input, .input-group select {
            width: 100%;
            padding: 10px 12px;
            border: 2px solid #e8e8e8;
            border-radius: 10px;
            font-size: 0.85rem;
            transition: all 0.3s;
            background: #fafafa;
        }
        .input-group input:focus, .input-group select:focus {
            outline: none;
            border-color: #667eea;
            background: white;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }
        .address-list {
            max-height: 150px;
            overflow-y: auto;
            margin-bottom: 12px;
        }
        .address-list::-webkit-scrollbar {
            width: 6px;
        }
        .address-list::-webkit-scrollbar-track {
            background: #f1f1f1;
            border-radius: 10px;
        }
        .address-list::-webkit-scrollbar-thumb {
            background: #c1c1c1;
            border-radius: 10px;
        }
        .address-list::-webkit-scrollbar-thumb:hover {
            background: #a8a8a8;
        }
        .address-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 10px;
            background: #f8f9fa;
            border-radius: 8px;
            margin-bottom: 8px;
            font-size: 0.85rem;
        }
        .address-item .number {
            width: 28px;
            height: 28px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.8rem;
            font-weight: 700;
            margin-right: 12px;
            box-shadow: 0 2px 8px rgba(102, 126, 234, 0.3);
        }
        .address-item .text {
            flex: 1;
            color: #2c3e50;
        }
        .address-item .remove {
            color: #e74c3c;
            cursor: pointer;
            font-size: 1.2rem;
            padding: 0 5px;
        }
        .btn {
            width: 100%;
            padding: 11px;
            border: none;
            border-radius: 10px;
            font-size: 0.9rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            margin-bottom: 8px;
        }
        .btn-primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
        }
        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.5);
        }
        .btn-success {
            background: linear-gradient(135deg, #11998e 0%, #38ef7d 100%);
            color: white;
            box-shadow: 0 4px 15px rgba(56, 239, 125, 0.4);
        }
        .btn-success:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(56, 239, 125, 0.5);
        }
        .btn-secondary {
            background: #f5f5f5;
            color: #2c3e50;
            border: 2px solid #e8e8e8;
        }
        .btn-secondary:hover {
            background: #ebebeb;
            border-color: #d5d5d5;
        }

        /* Toggle Buttons for Optimization Mode */
        .optimization-toggle {
            display: flex;
            gap: 8px;
            margin-bottom: 15px;
        }
        .toggle-btn {
            flex: 1;
            padding: 10px 8px;
            border: 2px solid #e8e8e8;
            border-radius: 10px;
            background: white;
            color: #7f8c8d;
            font-size: 0.85rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            text-align: center;
        }
        .toggle-btn:hover {
            border-color: #667eea;
            color: #667eea;
        }
        .toggle-btn.active {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border-color: #667eea;
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.3);
        }
        .toggle-btn-icon {
            font-size: 1.2rem;
            display: block;
            margin-bottom: 4px;
        }
        .map-container {
            background: white;
            border-radius: 16px;
            padding: 20px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.12);
            overflow: hidden;
            height: 100%;
        }
        #map {
            height: 100%;
            border-radius: 12px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }
        .results-panel {
            background: white;
            border-radius: 16px;
            padding: 20px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.12);
            display: none;
            flex-direction: column;
            overflow: hidden;
            height: 100%;
        }
        .results-panel.show {
            display: flex;
        }
        .results {
            flex: 1;
            overflow-y: auto;
            padding: 15px;
            background: linear-gradient(135deg, #e8f6f3 0%, #d5f4e6 100%);
            border-radius: 12px;
            border: 2px solid #c8e6c9;
        }
        .results.empty {
            display: flex;
            align-items: center;
            justify-content: center;
            color: #95a5a6;
            font-style: italic;
            font-size: 0.9rem;
        }
        .results::-webkit-scrollbar {
            width: 6px;
        }
        .results::-webkit-scrollbar-track {
            background: #f1f1f1;
            border-radius: 10px;
        }
        .results::-webkit-scrollbar-thumb {
            background: #c1c1c1;
            border-radius: 10px;
        }
        .results::-webkit-scrollbar-thumb:hover {
            background: #a8a8a8;
        }
        .results-header {
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 2px solid #667eea;
        }
        .results-header h3 {
            color: #667eea;
            font-size: 1.1rem;
            margin: 0;
        }
        .results h3 {
            color: #1e8449;
            margin-bottom: 8px;
            font-size: 0.95rem;
        }
        .results p {
            color: #2c3e50;
            font-size: 0.85rem;
            margin-bottom: 4px;
        }
        .route-list {
            margin-top: 12px;
        }
        .route-item {
            display: flex;
            align-items: center;
            padding: 6px 0;
            font-size: 0.8rem;
        }
        .route-item:not(:last-child) {
            border-bottom: 1px solid #d5dbdb;
        }
        .route-item .step {
            width: 28px;
            height: 28px;
            background: linear-gradient(135deg, #11998e 0%, #38ef7d 100%);
            color: white;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.8rem;
            font-weight: 700;
            margin-right: 12px;
            flex-shrink: 0;
            box-shadow: 0 2px 8px rgba(56, 239, 125, 0.3);
        }
        @media (max-width: 1400px) {
            .main-content.with-results {
                grid-template-columns: 320px 1fr 340px;
            }
        }
        @media (max-width: 1200px) {
            .main-content.with-results {
                grid-template-columns: 300px 1fr;
            }
            .results-panel {
                display: none !important;
            }
        }
        @media (max-width: 768px) {
            header h1 {
                font-size: 1.5rem;
            }
            header p {
                font-size: 0.85rem;
            }
            header {
                padding: 15px 0 10px;
            }
            .container {
                padding: 0 12px;
            }
            .main-content {
                display: flex;
                flex-direction: column;
                gap: 12px;
            }
            .mobile-tabs {
                display: block;
            }
            .sidebar {
                display: none;
                max-height: none;
                height: auto;
                flex: 1;
                min-height: 0;
            }
            .sidebar.mobile-active {
                display: flex;
            }
            .sidebar-toggle {
                display: none;
            }
            .map-container {
                display: none;
                height: 100%;
                min-height: 400px;
            }
            .map-container.mobile-active {
                display: block;
            }
            .results-panel {
                display: none !important;
            }
            .results-bottom-sheet {
                display: block;
            }
            /* Larger touch targets for mobile */
            .btn {
                padding: 14px;
                font-size: 1rem;
                margin-bottom: 10px;
            }
            .address-item .remove {
                font-size: 1.5rem;
                padding: 0 10px;
                min-width: 44px;
                min-height: 44px;
                display: flex;
                align-items: center;
                justify-content: center;
            }
            .toggle-btn {
                padding: 12px 8px;
            }
            .input-group input {
                padding: 12px 14px;
                font-size: 1rem;
            }
        }
        @media (max-width: 480px) {
            .container {
                padding: 0 8px;
            }
            header h1 {
                font-size: 1.3rem;
            }
            .sidebar {
                padding: 15px;
            }
            .map-container {
                padding: 12px;
            }
        }
        .route-leg-info {
            padding: 4px 0 8px 34px;
            color: #7f8c8d;
            font-size: 0.8rem;
        }
        .traffic-badge {
            display: inline-block;
            padding: 2px 6px;
            border-radius: 4px;
            font-size: 0.75rem;
            font-weight: 600;
            margin-left: 5px;
        }
        .traffic-green { background: #d5f5e3; color: #1e8449; }
        .traffic-yellow { background: #fef9e7; color: #9a7d0a; }
        .traffic-red { background: #fadbd8; color: #c0392b; }
        .loading {
            text-align: center;
            padding: 20px;
            color: #7f8c8d;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>Route Optimizer</h1>
            <p>Save time by finding the best route with real-time traffic data</p>
        </header>
        
        <div class="main-content">
            <!-- Mobile tabs (hidden on desktop) -->
            <div class="mobile-tabs">
                <div class="mobile-tabs-container">
                    <button class="mobile-tab active" onclick="switchMobileTab('locations')" id="tabLocations">
                        <span class="mobile-tab-icon">üìç</span>
                        Locations
                    </button>
                    <button class="mobile-tab" onclick="switchMobileTab('map')" id="tabMap">
                        <span class="mobile-tab-icon">üó∫Ô∏è</span>
                        Map
                    </button>
                    <button class="mobile-tab" onclick="switchMobileTab('route')" id="tabRoute">
                        <span class="mobile-tab-icon">üöÄ</span>
                        Route
                    </button>
                </div>
            </div>

            <div class="sidebar mobile-active">
                <button class="sidebar-toggle" onclick="toggleSidebar()" id="sidebarToggle">
                    ‚óÄ
                </button>
                <div class="sidebar-content">
                    <h2 class="section-title">Add Locations</h2>
                    <div class="input-group">
                        <label>Starting Point (Optional)</label>
                        <input type="text" id="startAddress" placeholder="Enter starting address">
                    </div>
                    <div class="input-group">
                        <label>Destination (Optional)</label>
                        <input type="text" id="endAddress" placeholder="Enter destination address">
                    </div>
                    <div class="input-group">
                        <label>Waypoints (Addresses to Visit)</label>
                        <input type="text" id="waypointInput" placeholder="Enter address">
                    </div>
                    <button class="btn btn-secondary" onclick="addWaypoint()">+ Add Waypoint</button>

                    <div class="address-list" id="addressList"></div>

                    <div style="margin-bottom: 8px;">
                        <label style="display: block; font-size: 0.8rem; color: #7f8c8d; margin-bottom: 6px;">Optimization Mode</label>
                        <div class="optimization-toggle">
                            <div class="toggle-btn active" id="timeBtn" onclick="selectMode('time')">
                                <span class="toggle-btn-icon">‚è±Ô∏è</span>
                                Fastest
                            </div>
                            <div class="toggle-btn" id="distanceBtn" onclick="selectMode('distance')">
                                <span class="toggle-btn-icon">üìè</span>
                                Shortest
                            </div>
                        </div>
                    </div>

                    <button class="btn btn-primary" onclick="optimizeRoute()">üöÄ Optimize Route</button>
                    <button class="btn btn-secondary" onclick="clearAll()">Clear All</button>
                </div>
            </div>
            
            <div class="map-container">
                <div id="map"></div>
            </div>

            <div class="results-panel" id="resultsPanel">
                <div class="results-header">
                    <h3>üìç Route Results</h3>
                </div>
                <div class="results" id="results"></div>
            </div>
        </div>

        <!-- Mobile bottom sheet for results -->
        <div class="results-bottom-sheet" id="resultsBottomSheet">
            <div class="bottom-sheet-handle"></div>
            <div class="bottom-sheet-header">
                <h3 style="margin: 0; font-size: 1.1rem;">üìç Route Results</h3>
                <button class="bottom-sheet-close" onclick="closeBottomSheet()">√ó</button>
            </div>
            <div class="bottom-sheet-content" id="resultsBottomSheetContent"></div>
        </div>
    </div>

    <script>
        // VERSION 3.0 - Responsive Design with Mobile Support
        const API_KEY = 'AIzaSyBOGxIR4LbxsFDHNkVGa_U1l7kSb8iWYks';
        let map;
        let directionsService;
        let directionsRenderer;
        let geocoder;
        let distanceMatrixService;
        let markers = [];
        let waypointCount = 0;
        let waypoints = [];
        let startPoint = null;
        let endPoint = null;
        let durationMatrix = null;
        let distanceMatrix = null;
        let optimizationMode = 'time'; // Default mode

        // Toggle button function
        function selectMode(mode) {
            optimizationMode = mode;
            const timeBtn = document.getElementById('timeBtn');
            const distanceBtn = document.getElementById('distanceBtn');

            if (mode === 'time') {
                timeBtn.classList.add('active');
                distanceBtn.classList.remove('active');
            } else {
                distanceBtn.classList.add('active');
                timeBtn.classList.remove('active');
            }
        }

        // Mobile tab switching
        function switchMobileTab(tab) {
            // Update tab buttons
            document.querySelectorAll('.mobile-tab').forEach(t => t.classList.remove('active'));
            document.getElementById('tab' + tab.charAt(0).toUpperCase() + tab.slice(1)).classList.add('active');

            // Show/hide panels
            const sidebar = document.querySelector('.sidebar');
            const mapContainer = document.querySelector('.map-container');

            sidebar.classList.remove('mobile-active');
            mapContainer.classList.remove('mobile-active');

            if (tab === 'locations') {
                sidebar.classList.add('mobile-active');
            } else if (tab === 'map') {
                mapContainer.classList.add('mobile-active');
                // Trigger map resize to fix display issues
                if (map) {
                    google.maps.event.trigger(map, 'resize');
                }
            } else if (tab === 'route') {
                openBottomSheet();
            }
        }

        // Sidebar collapse toggle for desktop
        function toggleSidebar() {
            const sidebar = document.querySelector('.sidebar');
            const toggle = document.getElementById('sidebarToggle');

            sidebar.classList.toggle('collapsed');
            toggle.textContent = sidebar.classList.contains('collapsed') ? '‚ñ∂' : '‚óÄ';

            // Trigger map resize
            setTimeout(() => {
                if (map) {
                    google.maps.event.trigger(map, 'resize');
                }
            }, 300);
        }

        // Bottom sheet controls
        function openBottomSheet() {
            const bottomSheet = document.getElementById('resultsBottomSheet');
            bottomSheet.classList.add('show');
        }

        function closeBottomSheet() {
            const bottomSheet = document.getElementById('resultsBottomSheet');
            bottomSheet.classList.remove('show');
        }

        // Check if mobile view
        function isMobileView() {
            return window.innerWidth <= 768;
        }

        // Update results in both desktop panel and mobile bottom sheet
        function updateResults(htmlContent) {
            const resultsDiv = document.getElementById('results');
            const bottomSheetContent = document.getElementById('resultsBottomSheetContent');

            resultsDiv.innerHTML = htmlContent;
            bottomSheetContent.innerHTML = htmlContent;

            // Show results panel on desktop
            if (!isMobileView()) {
                document.getElementById('resultsPanel').classList.add('show');
                document.querySelector('.main-content').classList.add('with-results');
            } else {
                // On mobile, show bottom sheet and switch to route tab
                openBottomSheet();
            }
        }

        function initMap() {
            try {
                map = new google.maps.Map(document.getElementById('map'), {
                    center: { lat: 39.8283, lng: -98.5795 },
                    zoom: 4,
                    mapTypeId: 'roadmap'
                });

                directionsService = new google.maps.DirectionsService();
                distanceMatrixService = new google.maps.DistanceMatrixService();
                directionsRenderer = new google.maps.DirectionsRenderer({
                    map: map,
                    suppressMarkers: true,
                    polylineOptions: {
                        strokeColor: '#3498db',
                        strokeWeight: 4
                    }
                });

                geocoder = new google.maps.Geocoder();
            } catch (error) {
                console.error('Error initializing Google Maps:', error);
                document.getElementById('map').innerHTML = '<div style="padding: 20px; text-align: center;"><h3 style="color: #e74c3c;">Google Maps Error</h3><p style="color: #7f8c8d;">Unable to load Google Maps. Please check the API key and ensure all required APIs are enabled.</p><p style="color: #7f8c8d; font-size: 0.85rem; margin-top: 10px;">Required APIs: Maps JavaScript API, Directions API, Distance Matrix API, Geocoding API</p></div>';
            }
        }

        // Make initMap globally accessible for Google Maps callback
        window.initMap = initMap;

        // Make other functions globally accessible for onclick handlers
        window.switchMobileTab = switchMobileTab;
        window.toggleSidebar = toggleSidebar;
        window.openBottomSheet = openBottomSheet;
        window.closeBottomSheet = closeBottomSheet;

        function geocodeAddress(address) {
            return new Promise((resolve, reject) => {
                geocoder.geocode({ address: address }, (results, status) => {
                    if (status === 'OK' && results && results.length > 0) {
                        const location = results[0].geometry.location;
                        resolve({ 
                            lat: location.lat(), 
                            lng: location.lng(),
                            formattedAddress: results[0].formatted_address
                        });
                    } else {
                        resolve(null);
                    }
                });
            });
        }

        async function addWaypoint() {
            const input = document.getElementById('waypointInput');
            const address = input.value.trim();
            
            if (address) {
                const coords = await geocodeAddress(address);
                if (coords) {
                    waypointCount++;
                    const displayNumber = waypointCount;
                    waypoints.push({ 
                        address: address, 
                        lat: coords.lat, 
                        lng: coords.lng, 
                        isWaypoint: true 
                    });
                    addMarker(coords.lat, coords.lng, address, displayNumber);
                    updateAddressList();
                } else {
                    alert(`Could not find address: ${address}`);
                }
                input.value = '';
            }
        }

        function updateAddressList() {
            const list = document.getElementById('addressList');
            list.innerHTML = waypoints.map((wp, index) => `
                <div class="address-item">
                    <span class="number">${index}</span>
                    <span class="text">${wp.address}</span>
                    <span class="remove" onclick="removeAddress(${index})">√ó</span>
                </div>
            `).join('');
        }

        function removeAddress(index) {
            clearMap();
            waypoints.splice(index, 1);
            waypointCount--;
            updateAddressList();
            waypoints.forEach((wp, i) => {
                addMarker(wp.lat, wp.lng, wp.address, i + 1);
            });
        }

        function addMarker(lat, lng, address, number) {
            const marker = new google.maps.Marker({
                position: { lat: lat, lng: lng },
                map: map,
                label: {
                    text: number.toString(),
                    color: 'white',
                    fontSize: '12px',
                    fontWeight: 'bold'
                },
                icon: {
                    path: google.maps.SymbolPath.CIRCLE,
                    scale: 15,
                    fillColor: '#3498db',
                    fillOpacity: 1,
                    strokeColor: 'white',
                    strokeWeight: 2
                }
            });
            marker.addListener('click', () => {
                const infoWindow = new google.maps.InfoWindow({
                    content: `<div style="font-size: 14px;"><b>Stop ${number}</b><br>${address}</div>`
                });
                infoWindow.open(map, marker);
            });
            markers.push(marker);
        }

        function clearMap() {
            markers.forEach(m => m.setMap(null));
            markers = [];
            if (directionsRenderer) {
                directionsRenderer.setDirections({ routes: [] });
            }
        }

        function clearAll() {
            waypoints = [];
            waypointCount = 0;
            startPoint = null;
            endPoint = null;
            durationMatrix = null;
            distanceMatrix = null;
            updateAddressList();
            clearMap();

            // Hide results panel and bottom sheet
            document.getElementById('resultsPanel').classList.remove('show');
            document.querySelector('.main-content').classList.remove('with-results');
            document.getElementById('results').innerHTML = '';
            document.getElementById('resultsBottomSheetContent').innerHTML = '';
            closeBottomSheet();

            document.getElementById('startAddress').value = '';
            document.getElementById('endAddress').value = '';
            document.getElementById('waypointInput').value = '';
        }

        async function getDistanceMatrix(allPoints) {
            const origins = allPoints.map(p => new google.maps.LatLng(p.lat, p.lng));
            const destinations = allPoints.map(p => new google.maps.LatLng(p.lat, p.lng));

            return new Promise((resolve, reject) => {
                const request = {
                    origins: origins,
                    destinations: destinations,
                    travelMode: google.maps.TravelMode.DRIVING,
                    drivingOptions: {
                        departureTime: new Date(),
                        trafficModel: google.maps.TrafficModel.BEST_GUESS
                    },
                    unitSystem: google.maps.UnitSystem.METRIC
                };

                distanceMatrixService.getDistanceMatrix(request, (response, status) => {
                    if (status === 'OK' && response && response.rows) {
                        const durations = [];
                        const distances = [];
                        
                        response.rows.forEach(row => {
                            const rowDurations = [];
                            const rowDistances = [];
                            row.elements.forEach(element => {
                                if (element.status === 'OK') {
                                    rowDurations.push(element.duration.value);
                                    rowDistances.push(element.distance.value);
                                } else {
                                    rowDurations.push(null);
                                    rowDistances.push(null);
                                }
                            });
                            durations.push(rowDurations);
                            distances.push(rowDistances);
                        });

                        // Log the complete distance matrix
                        console.log('=== COMPLETE DISTANCE MATRIX ===');
                        console.log('Points:', allPoints.map((p, i) => `${i}: ${p.address}`));
                        console.log('\nMatrix values (Time in seconds | Distance in meters):');
                        durations.forEach((row, i) => {
                            row.forEach((duration, j) => {
                                if (duration !== null && i !== j) {
                                    const distMeters = distances[i][j];
                                    const distKm = (distMeters / 1000).toFixed(1);
                                    const minutes = Math.round(duration / 60);
                                    console.log(`  [${i}]‚Üí[${j}]: TIME=${duration}s (${minutes}m) | DIST=${distMeters}m (${distKm}km)`);
                                }
                            });
                        });
                        console.log('================================\n');

                        resolve({ durations, distances });
                    } else {
                        resolve(null);
                    }
                });
            });
        }

        function nearestNeighborFromPoint(startIdx, points, durationMatrix) {
            const visitedIndices = [startIdx];
            const unvisitedIndices = points.map((_, i) => i).filter(i => i !== startIdx);
            
            while (unvisitedIndices.length > 0) {
                const lastIdx = visitedIndices[visitedIndices.length - 1];
                let nearestIdx = -1;
                let nearestDuration = Infinity;
                
                for (const idx of unvisitedIndices) {
                    const duration = durationMatrix[lastIdx][idx];
                    if (duration !== null && duration < nearestDuration) {
                        nearestDuration = duration;
                        nearestIdx = idx;
                    }
                }
                
                if (nearestIdx >= 0) {
                    visitedIndices.push(nearestIdx);
                    unvisitedIndices.splice(unvisitedIndices.indexOf(nearestIdx), 1);
                } else {
                    break;
                }
            }
            
            return visitedIndices;
        }

        function twoOptOptimization(routeIndices, durationMatrix, startIndex, endIndex) {
            console.log('Two-opt input route:', routeIndices, 'startIndex:', startIndex, 'endIndex:', endIndex);
            let improved = true;
            let bestRoute = [...routeIndices];
            let iterations = 0;
            
            while (improved && iterations < 100) {
                improved = false;
                iterations++;
                
                for (let i = 0; i < bestRoute.length - 1; i++) {
                    for (let j = i + 2; j < bestRoute.length; j++) {
                        if (j === bestRoute.length - 1 && i === 0) continue;
                        
                        const newRoute = [...bestRoute];
                        const segment = newRoute.slice(i + 1, j + 1).reverse();
                        newRoute.splice(i + 1, segment.length, ...segment);
                        
                        const oldDuration = calculateRouteDuration(bestRoute, durationMatrix, startIndex, endIndex);
                        const newDuration = calculateRouteDuration(newRoute, durationMatrix, startIndex, endIndex);
                        
                        console.log(`Two-opt test i=${i}, j=${j}: oldRoute=${bestRoute}, newRoute=${newRoute}, old=${oldDuration}s, new=${newDuration}s`);
                        
                        if (newDuration < oldDuration) {
                            console.log(`Improvement found! oldDuration=${oldDuration}s, newDuration=${newDuration}s`);
                            bestRoute = newRoute;
                            improved = true;
                        }
                    }
                }
            }
            
            console.log(`Two-opt output after ${iterations} iterations:`, bestRoute, 'duration:', calculateRouteDuration(bestRoute, durationMatrix, startIndex, endIndex) + 's');
            return bestRoute;
        }
        
        function calculateRouteDuration(allPoints, routeIndices, durationMatrix, hasStartPoint) {
            let total = 0;
            let previousIdx = hasStartPoint ? 0 : routeIndices[0];
            
            for (let i = (hasStartPoint ? 0 : 1); i < routeIndices.length; i++) {
                const currentIdx = routeIndices[i];
                if (durationMatrix[previousIdx][currentIdx] !== null) {
                    total += durationMatrix[previousIdx][currentIdx];
                }
                previousIdx = currentIdx;
            }
            
            return total;
        }
        
        function twoOptSimple(routeIndices, durationMatrix) {
            let improved = true;
            let bestRoute = [...routeIndices];
            let iterations = 0;
            
            while (improved && iterations < 100) {
                improved = false;
                iterations++;
                
                for (let i = 0; i < bestRoute.length - 1; i++) {
                    for (let j = i + 2; j < bestRoute.length; j++) {
                        if (j === bestRoute.length - 1 && i === 0) continue;
                        
                        const newRoute = [...bestRoute];
                        const segment = newRoute.slice(i, j + 1).reverse();
                        newRoute.splice(i, segment.length, ...segment);
                        
                        const oldDuration = calculateRouteDuration(routeIndices, bestRoute, durationMatrix, false);
                        const newDuration = calculateRouteDuration(routeIndices, newRoute, durationMatrix, false);
                        
                        if (newDuration < oldDuration) {
                            bestRoute = newRoute;
                            improved = true;
                        }
                    }
                }
            }
            
            return bestRoute;
        }

        function optimizeWaypointsOnly(startPoint, waypoints, endPoint, durationMatrix) {
            if (waypoints.length <= 1) return waypoints;
            
            const waypointMatrixIndices = waypoints.map((_, i) => i + (startPoint ? 1 : 0));
            const startIndex = startPoint ? 0 : null;
            const endIndex = endPoint ? durationMatrix.length - 1 : null;
            
            let bestRouteIndices = null;
            let bestDuration = Infinity;
            
            for (let i = 0; i < waypointMatrixIndices.length; i++) {
                const routeWaypointIndices = [waypointMatrixIndices[i]];
                const remainingIndices = waypointMatrixIndices.filter(idx => idx !== waypointMatrixIndices[i]);
                
                let currentIdx = waypointMatrixIndices[i];
                
                while (remainingIndices.length > 0) {
                    let nearestIdx = -1;
                    let nearestDuration = Infinity;
                    
                    for (const idx of remainingIndices) {
                        const duration = durationMatrix[currentIdx][idx];
                        if (duration !== null && duration < nearestDuration) {
                            nearestDuration = duration;
                            nearestIdx = idx;
                        }
                    }
                    
                    if (nearestIdx >= 0) {
                        routeWaypointIndices.push(nearestIdx);
                        currentIdx = nearestIdx;
                        remainingIndices.splice(remainingIndices.indexOf(nearestIdx), 1);
                    } else {
                        break;
                    }
                }
                
                const totalDuration = calculateRouteDuration(routeWaypointIndices, durationMatrix, startIndex, endIndex);
                
                if (totalDuration < bestDuration) {
                    bestDuration = totalDuration;
                    bestRouteIndices = routeWaypointIndices;
                }
            }
            
            const optimizedRoute = twoOptOptimization(bestRouteIndices, durationMatrix, startIndex, endIndex);
            
            return optimizedRoute.map(matrixIdx => ({ 
                ...waypoints[matrixIdx - (startPoint ? 1 : 0)], 
                matrixIndex: matrixIdx 
            }));
        }

        async function displayRoute(optimized, durationMatrix, distanceMatrix) {
            const waypointLocations = optimized.map(p => ({ location: { lat: p.lat, lng: p.lng } }));
            
            if (optimized.length >= 2) {
                const request = {
                    origin: waypointLocations[0].location,
                    destination: waypointLocations[waypointLocations.length - 1].location,
                    waypoints: waypointLocations.slice(1, -1),
                    travelMode: google.maps.TravelMode.DRIVING,
                    drivingOptions: {
                        departureTime: new Date(),
                        trafficModel: google.maps.TrafficModel.BEST_GUESS
                    },
                    optimizeWaypoints: false,
                    provideRouteAlternatives: false
                };

                directionsService.route(request, (response, status) => {
                    if (status === 'OK' && response && response.routes && response.routes.length > 0) {
                        directionsRenderer.setDirections(response);
                        const bounds = new google.maps.LatLngBounds();
                        optimized.forEach(p => bounds.extend({ lat: p.lat, lng: p.lng }));
                        map.fitBounds(bounds);
                    }
                });
            }

            let totalDuration = 0;
            let totalDistance = 0;
            
            for (let i = 0; i < optimized.length - 1; i++) {
                const idx1 = optimized[i].matrixIndex;
                const idx2 = optimized[i + 1].matrixIndex;
                
                if (durationMatrix[idx1][idx2] !== null) {
                    totalDuration += durationMatrix[idx1][idx2];
                    totalDistance += distanceMatrix[idx1][idx2];
                }
            }

            const hours = Math.floor(totalDuration / 3600);
            const minutes = Math.floor((totalDuration % 3600) / 60);
            const timeStr = hours > 0 ? `${hours}h ${minutes}m` : `${minutes}m`;
            const distanceStr = (totalDistance / 1000).toFixed(1);
            
            let routeDetails = '';
            for (let i = 0; i < optimized.length - 1; i++) {
                const current = optimized[i];
                const next = optimized[i + 1];
                
                const idx1 = current.matrixIndex;
                const idx2 = next.matrixIndex;
                
                let duration = 0;
                let distance = 0;
                let durationInTraffic = 0;
                let trafficClass = 'traffic-green';
                
                if (durationMatrix[idx1][idx2] !== null) {
                    duration = durationMatrix[idx1][idx2];
                    distance = distanceMatrix[idx1][idx2];
                    durationInTraffic = duration;
                }
                
                const durHours = Math.floor(durationInTraffic / 3600);
                const durMinutes = Math.floor((durationInTraffic % 3600) / 60);
                const durStr = durHours > 0 ? `${durHours}h ${durMinutes}m` : `${durMinutes}m`;
                
                routeDetails += `
                    <div class="route-item">
                        <span class="step">${i}</span>
                        <span>${current.address}</span>
                    </div>
                    <div class="route-leg-info">
                        ‚Üì ${(distance / 1000).toFixed(1)} km, ${durStr} <span class="traffic-badge ${trafficClass}">Live Traffic</span>
                    </div>
                `;
            }
            
            routeDetails += `
                <div class="route-item">
                    <span class="step">${optimized.length - 1}</span>
                    <span>${optimized[optimized.length - 1].address}</span>
                </div>
            `;
            
            const resultsHTML = `
                <div style="margin-bottom: 15px; padding: 15px; background: white; border-radius: 10px; box-shadow: 0 2px 8px rgba(0,0,0,0.08);">
                    <div style="display: flex; align-items: center; justify-content: space-between; gap: 15px;">
                        <div style="flex: 1;">
                            <p style="margin: 0 0 3px 0; font-size: 0.75rem; color: #7f8c8d; text-transform: uppercase; letter-spacing: 0.5px;">Distance</p>
                            <p style="margin: 0; font-size: 1.4rem; font-weight: 700; color: #27ae60;">${distanceStr} km</p>
                        </div>
                        <div style="width: 2px; height: 40px; background: linear-gradient(to bottom, #e8e8e8, #f5f5f5);"></div>
                        <div style="flex: 1;">
                            <p style="margin: 0 0 3px 0; font-size: 0.75rem; color: #7f8c8d; text-transform: uppercase; letter-spacing: 0.5px;">Time</p>
                            <p style="margin: 0; font-size: 1.4rem; font-weight: 700; color: #3498db;">${timeStr}</p>
                            <p style="margin: 3px 0 0 0; font-size: 0.7rem; color: #27ae60;">‚ö° Live Traffic</p>
                        </div>
                    </div>
                </div>
                <div style="font-size: 0.85rem; font-weight: 600; color: #2c3e50; margin-bottom: 10px; padding-bottom: 8px; border-bottom: 2px solid #f0f0f0;">üìç Route Steps</div>
                <div class="route-list">
                    ${routeDetails}
                </div>
            `;

            updateResults(resultsHTML);
            document.getElementById('results').classList.remove('empty');
        }

        function optimizeWithBoth(waypoints, optimizationMatrix) {
            if (waypoints.length <= 1) return waypoints.map((p, i) => i);

            console.log('=== Optimize with Both Start and End (BRUTE FORCE) ===');
            console.log('Waypoints:', waypoints.map((w, i) => `${i}: ${w.address}`));

            const startPointIndex = 0; // Start is at matrix index 0
            const endPointIndex = waypoints.length + 1; // End is at last matrix index
            const waypointIndices = waypoints.map((_, i) => i + 1); // Waypoints are at indices 1, 2, 3...

            let bestRoute = null;
            let bestCost = Infinity;

            // Try all permutations of waypoints
            const permutations = getAllPermutations(waypointIndices);
            console.log(`Trying ${permutations.length} permutations...`);

            for (const perm of permutations) {
                let totalCost = 0;
                let valid = true;

                // Start to first waypoint
                totalCost += optimizationMatrix[startPointIndex][perm[0]] || 0;

                // Between waypoints
                for (let i = 0; i < perm.length - 1; i++) {
                    const cost = optimizationMatrix[perm[i]][perm[i + 1]];
                    if (cost === null) {
                        valid = false;
                        break;
                    }
                    totalCost += cost;
                }

                // Last waypoint to end
                if (valid) {
                    const lastWaypoint = perm[perm.length - 1];
                    const costToEnd = optimizationMatrix[lastWaypoint][endPointIndex];
                    if (costToEnd === null) {
                        valid = false;
                    } else {
                        totalCost += costToEnd;
                    }
                }

                if (valid && totalCost < bestCost) {
                    bestCost = totalCost;
                    bestRoute = perm.map(idx => idx - 1); // Convert matrix indices back to waypoint array indices
                }
            }

            console.log('Best route waypoint order:', bestRoute, 'total cost:', bestCost);

            return bestRoute;
        }

        /* ===== ROUTE OPTIMIZATION ALGORITHMS =====
         *
         * BRUTE FORCE ALGORITHM (Current Implementation):
         * - Tries ALL possible permutations of waypoints
         * - Guarantees finding the optimal solution
         * - Time complexity: O(n!) where n = number of waypoints
         * - Practical for up to ~10 waypoints (10! = 3.6M permutations)
         * - For 3 waypoints: only 6 permutations - very fast!
         *
         * Alternative algorithms for larger datasets:
         * - Nearest Neighbor: O(n¬≤) - fast but not optimal
         * - 2-opt: O(n¬≤) - improves existing route iteratively
         * - Genetic Algorithm: good for large n (50+)
         * - Christofides: guarantees within 50% of optimal
         * - Held-Karp (Dynamic Programming): O(n¬≤2^n) - exact but slower
         */

        // Generate all permutations of an array
        function getAllPermutations(arr) {
            if (arr.length <= 1) return [arr];
            const result = [];
            for (let i = 0; i < arr.length; i++) {
                const rest = [...arr.slice(0, i), ...arr.slice(i + 1)];
                const perms = getAllPermutations(rest);
                for (const perm of perms) {
                    result.push([arr[i], ...perm]);
                }
            }
            return result;
        }

        function optimizeWithStartOnly(waypoints, optimizationMatrix) {
            if (waypoints.length <= 1) return waypoints.map((p, i) => i);

            console.log('=== Optimize with Start Only (BRUTE FORCE) ===');
            console.log('Waypoints:', waypoints.map((w, i) => `${i}: ${w.address}`));

            const startPointIndex = 0; // Start point is at matrix index 0
            const waypointIndices = waypoints.map((_, i) => i + 1); // Waypoints are at indices 1, 2, 3...

            let bestRoute = null;
            let bestCost = Infinity;

            // Try all permutations of waypoints
            const permutations = getAllPermutations(waypointIndices);
            console.log(`Trying ${permutations.length} permutations...`);

            for (const perm of permutations) {
                let totalCost = 0;
                let valid = true;

                // Calculate cost from start to first waypoint
                totalCost += optimizationMatrix[startPointIndex][perm[0]] || 0;

                // Calculate cost between waypoints
                for (let i = 0; i < perm.length - 1; i++) {
                    const cost = optimizationMatrix[perm[i]][perm[i + 1]];
                    if (cost === null) {
                        valid = false;
                        break;
                    }
                    totalCost += cost;
                }

                if (valid && totalCost < bestCost) {
                    bestCost = totalCost;
                    bestRoute = perm.map(idx => idx - 1); // Convert matrix indices back to waypoint array indices
                }
            }

            console.log('Best route waypoint order:', bestRoute, 'total cost:', bestCost);
            console.log('Matrix indices:', bestRoute.map(i => i + 1));

            return bestRoute;
        }

        function optimizeWithEndOnly(waypoints, optimizationMatrix) {
            if (waypoints.length <= 1) return waypoints.map((p, i) => i);

            console.log('=== Optimize with End Only (BRUTE FORCE) ===');
            console.log('Waypoints:', waypoints.map((w, i) => `${i}: ${w.address}`));

            const endPointIndex = waypoints.length; // End point is at last matrix index
            const waypointIndices = waypoints.map((_, i) => i); // Waypoints are at indices 0, 1, 2...

            let bestRoute = null;
            let bestCost = Infinity;

            // Try all permutations of waypoints
            const permutations = getAllPermutations(waypointIndices);
            console.log(`Trying ${permutations.length} permutations...`);

            for (const perm of permutations) {
                let totalCost = 0;
                let valid = true;

                // Calculate cost between waypoints
                for (let i = 0; i < perm.length - 1; i++) {
                    const cost = optimizationMatrix[perm[i]][perm[i + 1]];
                    if (cost === null) {
                        valid = false;
                        break;
                    }
                    totalCost += cost;
                }

                // Add cost from last waypoint to end point
                if (valid) {
                    const lastWaypoint = perm[perm.length - 1];
                    const costToEnd = optimizationMatrix[lastWaypoint][endPointIndex];
                    if (costToEnd === null) {
                        valid = false;
                    } else {
                        totalCost += costToEnd;
                    }
                }

                if (valid && totalCost < bestCost) {
                    bestCost = totalCost;
                    bestRoute = perm;
                }
            }

            console.log('Best route:', bestRoute, 'total cost:', bestCost);

            return bestRoute;
        }
        
        function optimizeNoStartEnd(waypoints, optimizationMatrix) {
            if (waypoints.length <= 2) return waypoints.map((p, i) => i);

            console.log('=== Optimize without Start/End (BRUTE FORCE) ===');
            console.log('Waypoints:', waypoints.map((w, i) => `${i}: ${w.address}`));

            const waypointIndices = waypoints.map((_, i) => i);

            let bestRoute = null;
            let bestCost = Infinity;

            // Try all permutations
            const permutations = getAllPermutations(waypointIndices);
            console.log(`Trying ${permutations.length} permutations...`);

            for (const perm of permutations) {
                let totalCost = 0;
                let valid = true;

                // Calculate cost for the entire route
                for (let i = 0; i < perm.length - 1; i++) {
                    const cost = optimizationMatrix[perm[i]][perm[i + 1]];
                    if (cost === null) {
                        valid = false;
                        break;
                    }
                    totalCost += cost;
                }

                if (valid && totalCost < bestCost) {
                    bestCost = totalCost;
                    bestRoute = perm;
                }
            }

            console.log('Best route:', bestRoute, 'total cost:', bestCost);

            return bestRoute;
        }
        
        function optimizeWithEndOnly(waypoints, endPoint, durationMatrix) {
            if (waypoints.length <= 1) return waypoints.map((p, i) => ({ ...p, matrixIndex: i }));
            
            let bestRoute = null;
            let bestDuration = Infinity;
            
            const endPointIndex = waypoints.length;
            const waypointIndices = waypoints.map((_, i) => i);
            
            for (let startIdx = 0; startIdx < waypoints.length; startIdx++) {
                const startIndex = waypointIndices[startIdx];
                const middleWaypointIndices = waypointIndices.filter(idx => idx !== startIndex);
                
                let routeIndices = [startIndex];
                let currentIdx = startIndex;
                const remaining = [...middleWaypointIndices];
                
                while (remaining.length > 0) {
                    let nearestIdx = -1;
                    let nearestDuration = Infinity;
                    
                    for (const idx of remaining) {
                        const duration = durationMatrix[currentIdx][idx];
                        if (duration !== null && duration < nearestDuration) {
                            nearestDuration = duration;
                            nearestIdx = idx;
                        }
                    }
                    
                    if (nearestIdx >= 0) {
                        routeIndices.push(nearestIdx);
                        currentIdx = nearestIdx;
                        remaining.splice(remaining.indexOf(nearestIdx), 1);
                    } else {
                        break;
                    }
                }
                
                const totalDuration = calculateRouteDuration(routeIndices, durationMatrix, null, endPointIndex);
                
                if (totalDuration < bestDuration) {
                    bestDuration = totalDuration;
                    bestRoute = [...routeIndices];
                }
            }
            
            const optimizedRoute = twoOptOptimization(bestRoute, durationMatrix, null, endPointIndex);
            
            return optimizedRoute.map(matrixIdx => ({
                ...waypoints[matrixIdx],
                matrixIndex: matrixIdx
            }));
        }
        
        function optimizeNoStartEnd(waypoints, optimizationMatrix) {
            if (waypoints.length <= 2) return waypoints.map((p, i) => ({ ...p, matrixIndex: i }));
            
            let bestRoute = null;
            let bestDuration = Infinity;
            const waypointIndices = waypoints.map((_, i) => i);
            
            for (let startIdx = 0; startIdx < waypoints.length; startIdx++) {
                const startIndex = waypointIndices[startIdx];
                const otherIndices = waypointIndices.filter(idx => idx !== startIndex);
                
                let routeIndices = [startIndex];
                let currentIdx = startIndex;
                const remaining = [...otherIndices];
                
                while (remaining.length > 0) {
                    let nearestIdx = -1;
                    let nearestDuration = Infinity;
                    
                    for (const idx of remaining) {
                        const duration = durationMatrix[currentIdx][idx];
                        if (duration !== null && duration < nearestDuration) {
                            nearestDuration = duration;
                            nearestIdx = idx;
                        }
                    }
                    
                    if (nearestIdx >= 0) {
                        routeIndices.push(nearestIdx);
                        currentIdx = nearestIdx;
                        remaining.splice(remaining.indexOf(nearestIdx), 1);
                    } else {
                        break;
                    }
                }
                
                const totalDuration = calculateRouteDuration(routeIndices, durationMatrix, null, null);
                
                if (totalDuration < bestDuration) {
                    bestDuration = totalDuration;
                    bestRoute = [...routeIndices];
                }
            }
            
            const optimizedRoute = twoOptOptimization(bestRoute, durationMatrix, null, null);
            
            return optimizedRoute.map(matrixIdx => ({
                ...waypoints[matrixIdx],
                matrixIndex: matrixIdx
            }));
        }

        async function optimizeRoute() {
            if (waypoints.length < 2) {
                alert('Please add at least 2 waypoints to optimize');
                return;
            }

            clearMap();
            updateResults('<div class="loading">‚öôÔ∏è Optimizing route with real-time traffic data...</div>');
            document.getElementById('results').classList.remove('empty');
            
            let startAddr = document.getElementById('startAddress').value.trim();
            let endAddr = document.getElementById('endAddress').value.trim();
            
            if (startAddr) {
                const coords = await geocodeAddress(startAddr);
                if (coords) {
                    startPoint = { address: startAddr, lat: coords.lat, lng: coords.lng, isWaypoint: false };
                }
            }
            
            if (endAddr) {
                const coords = await geocodeAddress(endAddr);
                if (coords) {
                    endPoint = { address: endAddr, lat: coords.lat, lng: coords.lng, isWaypoint: false };
                }
            }
            
            let allPoints = [...waypoints];
            if (startPoint) allPoints.unshift(startPoint);
            if (endPoint) allPoints.push(endPoint);
            
            const matrixData = await getDistanceMatrix(allPoints);
            
            if (!matrixData) {
                const resultsDiv = document.getElementById('results');
                resultsDiv.classList.remove('empty');
                resultsDiv.innerHTML = '<div style="color: #e74c3c; text-align: center; padding: 20px;"><strong>‚ö†Ô∏è Error</strong><br/>Could not fetch route data. Please try again.</div>';
                return;
            }
            
            durationMatrix = matrixData.durations;
            distanceMatrix = matrixData.distances;

            // Use the global optimizationMode variable set by toggle buttons
            const optimizationMatrix = optimizationMode === 'distance' ? distanceMatrix : durationMatrix;

            console.log(`\n=== OPTIMIZATION MODE: ${optimizationMode === 'distance' ? 'SHORTEST DISTANCE' : 'SHORTEST TIME'} ===\n`);

            let waypointOrder = [];

            if (startPoint && endPoint) {
                const waypointsToOptimize = allPoints.slice(1, -1);
                waypointOrder = optimizeWithBoth(waypointsToOptimize, optimizationMatrix);
            } else if (startPoint && !endPoint) {
                waypointOrder = optimizeWithStartOnly(waypoints, optimizationMatrix);
            } else if (!startPoint && endPoint) {
                waypointOrder = optimizeWithEndOnly(waypoints, optimizationMatrix);
            } else {
                waypointOrder = optimizeNoStartEnd(waypoints, optimizationMatrix);
            }
            
            console.log('Optimized waypoint order:', waypointOrder);
            console.log('\n=== WAYPOINT TO MATRIX INDEX MAPPING ===');
            console.log('Original waypoints array:', waypoints.map((w, i) => `waypoints[${i}]="${w.address}" ‚Üí matrix index ${i + (startPoint ? 1 : 0)}`));
            console.log('Optimized visit order (waypoint array indices):', waypointOrder);

            optimized = [];
            if (startPoint) {
                optimized.push({ ...startPoint, matrixIndex: 0 });
                console.log(`Added start point: matrix index 0 = "${startPoint.address}"`);
            }
            waypointOrder.forEach((wpIndex, visitOrder) => {
                const matrixIdx = wpIndex + (startPoint ? 1 : 0);
                optimized.push({ ...waypoints[wpIndex], matrixIndex: matrixIdx });
                console.log(`Visit #${visitOrder + 1}: waypoints[${wpIndex}]="${waypoints[wpIndex].address}" ‚Üí matrix index ${matrixIdx}`);
            });
            if (endPoint) {
                optimized.push({ ...endPoint, matrixIndex: allPoints.length - 1 });
                console.log(`Added end point: matrix index ${allPoints.length - 1} = "${endPoint.address}"`);
            }
            console.log('=========================================\n');
            
            optimized.forEach((wp, i) => {
                addMarker(wp.lat, wp.lng, wp.address, i);
            });
            
            console.log('=== FINAL OPTIMIZED ROUTE ===');
            console.log('Route:', optimized.map((wp, i) => `${i}: ${wp.address}`).join('\n'));
            
            let finalDuration = 0;
            let finalDistance = 0;
            for (let i = 0; i < optimized.length - 1; i++) {
                const idx1 = optimized[i].matrixIndex;
                const idx2 = optimized[i + 1].matrixIndex;
                finalDuration += durationMatrix[idx1][idx2];
                finalDistance += distanceMatrix[idx1][idx2];
                console.log(`${i}‚Üí${i+1}: ${optimized[i].address} to ${optimized[i+1].address}: ${durationMatrix[idx1][idx2]}s (${Math.round(durationMatrix[idx1][idx2]/60)}m), ${(distanceMatrix[idx1][idx2]/1000).toFixed(1)}km`);
            }
            console.log('TOTAL:', finalDuration + 's (' + Math.round(finalDuration/60) + 'm),', (finalDistance/1000).toFixed(1) + 'km');
            
            try {
                await displayRoute(optimized, durationMatrix, distanceMatrix);

                // On mobile, switch to map tab to show the route
                if (isMobileView()) {
                    switchMobileTab('map');
                }
            } catch (error) {
                console.error('Error displaying route:', error);
                updateResults(`<div style="color: #e74c3c; text-align: center; padding: 20px;"><strong>‚ö†Ô∏è Error</strong><br/>${error.message}</div>`);
                document.getElementById('results').classList.remove('empty');
            }
        }

    </script>
    <script async defer src="https://maps.googleapis.com/maps/api/js?key=AIzaSyBOGxIR4LbxsFDHNkVGa_U1l7kSb8iWYks&callback=initMap"></script>
</body>
</html>
